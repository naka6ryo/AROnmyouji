ソフトウェア設計基準書．チーム開発向け．

版情報．v1．0．2026年1月17日．

1．目的．
本基準書は，チーム開発における設計判断を揃え，読みやすさと責務分離と繋ぎ合わせ容易性を高め，変更と拡張を安全にすることを目的とする．([Qiita][1])

2．適用範囲．
アプリケーション層，ドメイン層，インフラ層，UI層，およびそれらの結合点に適用する．
個人開発でも適用可だが，特に複数人での並行開発と統合の局面を主対象とする．([Qiita][2])

3．設計の最上位目標．
3．1 読みやすさを最優先とする．読みやすさとは，人間が楽に読め，安心して触れ，見たい部分だけを追える状態を指す．([Qiita][1])
3．2 触ってほしくない重要部位は隠し，安全に変更できる点だけを公開する．この制御を徹底する．([Qiita][1])
3．3 責務分離により，タスク分割と統合を容易にする．([Qiita][2])
3．4 設計に絶対解はない．プロジェクト条件に応じて粒度と厳格さを調整する．([Qiita][1])

4．必須ルールと推奨ルールの表記．
必須．違反はレビューで差し戻す．
推奨．原則守るが，状況で例外を認める．例外時は理由をコメントに残す．

5．SOLID運用指針．
5．1 単一責任の原則．必須．
各クラスは，こいつは何をするやつか，が一言で言える状態にする．([Qiita][1])
推奨として，クラスを，他人に見せる触らせるもの，他人に見せない触らせないもの，それらを繋ぐもの，に分け，繋ぐ役を混ぜ込まない．([Qiita][1])

5．2 オープン クローズドの原則．推奨．
機能追加は，既存コードを壊さずに行える構造を目指す．([Qiita][1])
運用ルールとして，追加は継承または委譲や差し替え点の追加で吸収し，既存ロジックの改変を最小化する．

5．3 リスコフの置換原則．推奨．
親のつもりで使われる子が期待を裏切らないことを保証する．([Qiita][1])
運用ルールとして，基底型の契約をテストで固定し，派生型はその契約を破らない．

5．4 インターフェース分離の原則．推奨．
関係ない仕事を押し付けない．必要な機能だけを実装すれば良い形にする．([Qiita][1])
ただし，分割のやりすぎは可読性を下げるため，仕様上常に同時に必要な機能はまとめる判断を許容する．([Qiita][1])

5．5 依存性逆転の原則．必須に近い推奨．
具体に依存せず，約束に依存する．チーム開発とテスト容易性を上げる．([Qiita][1])
運用ルールとして，共通のインターフェースを先に定義し，実装担当はそれぞれ独立に進められる形にする．([Qiita][1])

6．クラス設計基準．
6．1 クラス名は契約である．必須．
クラス名は見出しであり，読むべきか読まなくてよいかの判断材料である．ロジックが変わったら名前も見直す．([Qiita][2])

6．2 クラス名が示す責務境界を破らない．必須．
例として，Creator と名付けたなら生成以外を入れない．生成と削除のように反対の責務を混在させない．([Qiita][2])

6．3 機能追加時は追記より新規クラスを第一候補にする．推奨．
既存に足すのが楽，という発想が責務混在を生むため，まず責務に特化した新規クラス作成を検討し，次に既存との連携方法を考える．([Qiita][2])

6．4 繋ぐ役の隔離．推奨．
表示やデータの責務に，結合や制御の責務を混ぜない．繋ぐ役を分けることで，ロジック側のテスト容易性が上がる．([Qiita][1])

7．依存関係とインターフェース基準．
7．1 集合場所の定義．推奨．
クラス同士が直接参照し合うのではなく，共通インターフェースを集合場所として定義し，双方はそこに向かって実装する．([Qiita][1])

7．2 差し替え可能性．推奨．
本物の実装の代わりに偽物の保存機能などを差し替えられる構造を維持し，ユニットテストの質を上げる．([Qiita][1])

8．設計粒度の判断基準．
8．1 過剰設計を避ける．必須．
小さなクラスに過度な分割やパターン適用をすると，工数増と可読性低下を招く．状況に応じてまとめる判断を許容する．([Qiita][1])

8．2 コストの明示．推奨．
学習コスト，設計工数，ファイル数増大，追跡困難化，開発効率低下のリスクを認識し，チームのレベルと納期に合わせて設計を調整する．([Qiita][2])

9．レビュー用チェックリスト．
9．1 目的整合．読みやすさが上がっているか．責務分離ができているか．統合がしやすいか．([Qiita][2])
9．2 命名．クラス名が責務を一言で示すか．責務が変わったのに名前が据え置かれていないか．([Qiita][2])
9．3 責務境界．一つのクラスに生成と削除のような反対概念が混ざっていないか．([Qiita][2])
9．4 変更方針．機能追加で既存を無理に追記していないか．新規クラス化の検討がなされたか．([Qiita][2])
9．5 依存．具体実装への直接依存が多すぎないか．集合場所となるインターフェースが先に定義されているか．([Qiita][1])
9．6 分割温度感．分けすぎで全体像が追えない状態になっていないか．逆に責務混在で読めない状態になっていないか．([Qiita][1])

10．運用ルール．
10．1 例外管理．推奨ルールに反する場合は，状況依存の理由を簡潔に残す．([Qiita][1])
10．2 最低保証．設計原則を深く学んでいなくても，クラス名の責務だけは守る．これは不正解を出さないための最低ラインとする．([Qiita][2])

必要なら，この基準書を前提に，あなたの対象プロジェクトのレイヤ構成と命名規約の雛形まで落とし込んだ版も作れる．

[1]: https://qiita.com/nut_nuts_nut/items/97e13a8668141940b86d "SOLID原則ってなんのためにあるのか考えてみた #初心者 - Qiita"
[2]: https://qiita.com/nut_nuts_nut/items/f42c108bb0e5d1c6cff3 "設計されていないコードから学ぶ、チーム開発を成功させる設計術 #ハッカソン - Qiita"
